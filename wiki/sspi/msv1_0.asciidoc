ifdef::env-github[]
:note-caption: :pencil2:
endif::[]

= Microsoft Authentication Package v1.0
:toc: macro

The msv1_0 authentication package (AP) supports local machine logons.
It is also the security package (SP) for NTLM challenge-response authentication on a network.

toc::[]

== Functions

The protocol messages that msv1_0 supports is documented on MSDN and included here for conveniencefootnote:[https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/ne-ntsecapi-msv1_0_protocol_message_type[MSV1_0_PROTOCOL_MESSAGE_TYPE enumeration (ntsecapi.h)]]:

[%header]
|===
| Id     | Message Type               | CLI Support        | NT Version | Internal Function
| `0x00` | `Lm20ChallengeRequest`     | :heavy_check_mark: | `>=3.5`    | `MspLm20Challenge`
| `0x01` | `Lm20GetChallengeResponse` |                    | `>=3.5`    | `MspLm20GetChallengeResponse`
| `0x02` | `EnumerateUsers`           | :heavy_check_mark: | `>=3.5`    | `MspLm20EnumUsers`
| `0x03` | `GetUserInfo`              | :heavy_check_mark: | `>=3.5`    | `MspLm20GetUserInfo`
| `0x04` | `ReLogonUsers`             | :heavy_minus_sign: | `>=3.5`    | `MspLm20ReLogonUsers`
| `0x05` | `ChangePassword`           |                    | `>=3.5`    | `MspLm20ChangePassword`
| `0x06` | `ChangeCachedPassword`     | :heavy_check_mark: | `>=4.0`    | `MspLm20ChangePassword`
| `0x07` | `GenericPassthrough`       | _Planned_          | `>=5.0`    | `MspLm20GenericPassthrough`
| `0x08` | `CacheLogon`               | :x:                | `>=5.0`    | `MspLm20CacheLogon`
| `0x09` | `SubAuth`                  |                    | `>=5.0`    | `MspNtSubAuth`
| `0x0A` | `DeriveCredential`         | :heavy_check_mark: | `>=5.0`    | `MspNtDeriveCredential`
| `0x0B` | `CacheLookup`              | :x:                | `>=5.0`    | `MspLm20CacheLookup`
| `0x0C` | `SetProcessOption`         | :heavy_check_mark: | `>=5.1`    | `MspSetProcessOption`
| `0x0D` | `ConfigLocalAliases`       |                    | `>=6.0`    | `MspConfigLocalAliases`
| `0x0E` | `ClearCachedCredentials`   | :heavy_check_mark: | `>=6.0`    | `MspLm20ClearCachedCredentials`
| `0x0F` | `LookupToken`              |                    | `>=6.1`    | `MspLookupToken`
| `0x10` | `ValidateAuth`             |                    | `>=6.2`    | `MspValidateAuth`
| `0x11` | `CacheLookupEx`            | :x:                | `>=6.2`    | `MspLm20CacheLookup`
| `0x12` | `GetCredentialKey`         | :heavy_check_mark: | `>=6.2`    | `MspGetCredentialKey`
| `0x13` | `SetThreadOption`          | :heavy_check_mark: | `>=6.2`    | `MspSetThreadOption`
| `0x14` | `DecryptDpapiMasterKey`    | _Planned_          | `>=6.4`    | `MspDecryptDpapiMasterKey`
| `0x15` | `GetStrongCredentialKey`   | :heavy_check_mark: | `>=6.4`    | `MspGetStrongCredentialKey`
| `0x16` | `TransferCred`             | :heavy_check_mark: | `>=10.0`   | `MspTransferCreds`
| `0x17` | `ProvisionTbal`            | :heavy_check_mark: | `>=10.0`   | `MspProvisionTbal`
| `0x18` | `DeleteTbalSecrets`        | :heavy_check_mark: | `>=10.0`   | `MspDeleteTbalSecrets`
|===

NOTE: The internal function for each message type will be located in `msv1_0.dll`.

=== CacheLogon

Stores logon information in a logon session's cache.
The routine is used by the kerberos package to cache the NT OWF hash for a user logon session after it is recovered from a Privilege Attribute Certificate (PAC) for a ticket.
The command is restricted to only being callable by LSASS itself and as such is outside the scope of LSA Whisperer.

=== CacheLookup

Recovers logon information in a logon session's cache.
The information may include the associated user's NT OWF hash.
The command is restricted to only being callable by LSASS itself and as such is outside the scope of LSA Whisperer.

=== CacheLookupEx

Similar to the `CacheLookup` command, `CacheLookupEx` is restricted to only being callable by LSASS itself and as such is outside the scope of LSA Whisperer.

=== ChangeCachedPassword

This dispatch routine changes a password in the logon cache.
This is used when the password is changed on the domain controller using some other mechanism and the locally cached version needs to be updated to match the new value.
For example, RAS handles changing the passwords on the domain but then needs to update the cached copy so the user can still access servers.
`SeTcbPrivilege` is required if you are changing the cached entry for someone else.

```
msv1_0 ChangeCachedPassword --domain {name} --account {name} --oldpass {password} --newpass {password}
```

=== ChangePassword

Not implemented.
Appears at first to be coercible, but LSASS will impersonate itself and remove the admin (`S-1-5-32-544`) sid before making a connection to another computer.

=== ClearCachedCredentials

Clear the credentials in the local NTLM logon cache.
`SeTcbPrivilege` is required.

```
msv1_0 ClearCachedCredentials
```

=== DecryptDpapiMasterKey

Return a decrypted master key when provided pointers to an appropriate DPAPI prekey and other input data for a logon session.
The command is out of scope for the project becuase it would require the tool to supply valid pointers for LSASS's memory space.

=== DeleteTbalSecrets

Clear the Trusted Boot Auto-Logon (TBAL) secrets in the System vault.<sup>2</sup>

```
msv1_0 DeleteTbalSecrets
```

=== DeriveCredential

Get the [SHA1 HMAC](https://en.wikipedia.org/wiki/HMAC) for a provided message using an NT OWF or SHA1 OWF password as the key, specified by the logon session id.
The `--sha1v2` argument specifies to use the SHA1 OWF password instead of the NT OWF password.
`SeTcbPrivilege` may be required when specifying an id for another logon session but still need to verify that.

```
msv1_0 DeriveCredential --luid {session id} [--sha1v2] --message {ascii hex}
```

=== EnumerateUsers

Enumerates all interactive, service, and batch logons managed by MSV1_0.
The machine account logon will not be included in the list.

```
msv1_0 EnumerateUsers
```

=== GenericPassthrough

This dispatch routine passes any of the other dispatch routines to the domain controller.
The authentication package on the domain controller may choose to reject certain dispatch requests.

```
msv1_0 -d {function name} [function arguments]...
```

=== GetCredentialKey

Return all possible DPAPI prekeys from the primary credential structure for the logon session, regardless of the associated user's account type (e.g. local or domain).
The command will fail if the user does not have the `SeTcbPrivilege` privilege or credential isolation is enabled.

The primary credential structure may contain an LM OWF hash, NT OWF hash, SHA OWF hash, and a Cred key but only 2 keys will be returned.
The SHA OWF hash will always be returned which may be used as the DPAPI prekey if the account is local.
The 2nd key will either be the Cred Key if it is present or otherwise the NT OWF hash.
The 2nd key may be used if the account is a domain account.
The DPAPI prekeys may be used to decrypt the associated user's DPAPI master key or backup key files.

```
msv1_0 GetCredentialKey --luid {session id}
```

NOTE: The Cred Key is the same key referred to by Mimikatz as "DPAPI" under the "Primary" section of the command output for `sekurlsa::msv`.

=== GetStrongCredentialKey

Return the appropriate DPAPI prekey to use from the primary credential structure for the logon session.
Please refer to `GetCredentialKey` for more information about primary credentials.
The SHA OWF hash will be returned for local accounts and the Cred Key will be returned for domain accounts.

Additional handling is also done for GMSA credentials.
For GMSA accounts, the cleartext password for the service account is retrieved and converted to its NT OWF and SHA OWF equivalents for the primary credential structure if needed before the structure is referenced for the appropriate DPAPI prekey for the account.

The above description is how LSA Whisperer will operate when using the command but the command does have a 2nd mode of operation.
In the 2nd mode, the user should supply pointers to a SID and either a cleartext password or an NT OWF hash.
The account type for the SID will then be determined (e.g. local or group/domain) and then the appropriate DPAPI prekey is returned for the associated user.
The 2nd mode is out of scope for the project becuase it would require the tool to supply valid pointers for LSASS's memory space.

```
msv1_0 GetStrongCredentialKey ...
```

NOTE: The Cred Key is the same key referred to by Mimikatz as "DPAPI" under the "Primary" section of the command output for `sekurlsa::msv`.

=== GetUserInfo

Get information about a session id.

```
msv1_0 GetUserInfo --luid {session id}
```

=== Lm20ChallengeRequest

Get a challenge that may be delivered to a host that initiated an NTLMv2 logon.
Once a challenge response is received, it may be passed to `LsaLogonUser` with a `LogonType` of `MsV1_0Lm20Logon` to complete the logon.

```
msv1_0 Lm20ChallengeRequest
```

=== ProvisionTbal

Provision the Trusted Boot Auto-Logon (TBAL) LSA secrets for a logon session.footnote:[https://www.passcape.com/index.php?section=blog&cmd=details&id=38#a6[What is Trusted Boot Auto-Logon (TBAL)?]]
The host is required to be actively kernel debugged for the function to succeed.

```
msv1_0 ProvisionTbal --luid {session id}
```

=== SetProcessOption

Enable or disable an option for the calling process.
`SeTcbPrivilege` is required.
The currently known set of process options include:

- `AllowBlankPassword`
- `AllowOldPassword`
- `DisableAdminLockout`
- `DisableForceGuest`
- `TryCacheFirst`

MSV1_0 may internally check for one these options using `NtLmCheckProcessOption`.

```
msv1_0 SetProcessOption --option {process option} [--disable]
```

=== SetThreadOption

Enable or disable an option for the calling thread.
The set of options are the same as with the `SetProcessOption` command but they will take precedence over process options.
`SeTcbPrivilege` is required.

```
msv1_0 SetThreadOption --option {thread option} [--disable]
```

=== TransferCred

Transfer data between two msv1_0 logon sessions.
The specific data that is transferred and privileges that may be required are still being determined.
The function will ignore any flags that are provided.

```
msv1_0 TransferCred --sluid {session id} --dluid {session id}
```

== Sub-authentication Packages

Msv1_0 supports registering custom sub-authentication packages for extra user validation for local logons.
The only Micosoft developed sub-authentication package that could be identified was the "Microsoft IIS sub-authenticiation handler" implemented in the file `iissuba.dll`.
The `iissuba.dll` package has not shipped with Windows for a long time - hence it has not been included in the LSA Whisperer project.

== Key Terms

Reverse engineering some terms were key in understanding the internal message protocol functions that msv1_0 provides.
A description for each of these terms is provided here for others to use and research further.
These may not be completely accurate and contributions are appreciated.

=== Credential Key

In regards to the Data Protection API (DPAPI), Microsoft refers to the DPAPI prekey as Credential Key or Cred Key for short.
The Cred Key is used to decrypt a user's master key or backup key file for accessing DPAPI encrypted data.
The Cred Key for a local user will be the SHA OWF hash of the user's password.
The Cred Key for domain users will be the Secure Cred Key or the NT OWF hash for hosts older than NT 10 1604.

=== Credential Key Identifier

Microsoft will derive another value from a Cred Key for logging purposes which it calls the Cred Key Id.
The Cred Key Id is generated by msv1_0 may be seen in logs such as event Id 12289 from the Microsoft-Windows-Crypto-DPAPI provider.
Code for deriving a Cred Key Identifier is provided below.

[source,c++]
----
// Input data must be 0x14 bytes and will be the SHA OWF hash for a LocalUserCredKey
// or a null padded Cred Key, which are 0x10 bytes, for all other account types
std::string CredKeyId(BYTE* data, PSID sid) {
    std::string output;
    BCRYPT_KEY_HANDLE key;
    if (!BCryptGenerateSymmetricKey(BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE, &key, nullptr, 0, data, 0x14, 0)) {
        std::string label{ "DPAPICredKeyLogging" };
        std::wstring algorithm{ BCRYPT_SHA256_ALGORITHM };
        BCryptBuffer cryptBuffers[] = {
            {
                static_cast<ULONG>(label.size() + 1), // 0x14
                KDF_LABEL,
                const_cast<char*>(label.data()),
            }, {
                GetLengthSid(sid),
                KDF_CONTEXT,
                sid,
            }, {
                static_cast<ULONG>((algorithm.size() + 1) * sizeof(wchar_t)), // 0xe
                KDF_HASH_ALGORITHM,
                const_cast<wchar_t*>(algorithm.data()),
            }
        };
        BCryptBufferDesc parameterList;
        parameterList.ulVersion = 0;
        parameterList.cBuffers = 3;
        parameterList.pBuffers = cryptBuffers;
        UCHAR credKey[0x20];
        DWORD copiedBytes{ 0 };
        if (!BCryptKeyDerivation(key, &parameterList, credKey, 0x20, &copiedBytes, 0)) {
            output = std::string(reinterpret_cast<char*>(credKey), copiedBytes);
        }
        BCryptDestroyKey(key);
    }
    return output;
}
----

=== Secure Credential Key

Microsoft refers to Cred Keys used for domain accounts post NT 10 1607 as "Secure Cred Keys."
The reason for a new term is that a Secure Cred Key is generated differently than a normal Cred Key, as documented in different FOSS projects such as https://github.com/openwall/john/blob/4222aa48e282fdd608b4b54a7efadb834a999b42/run/DPAPImk2john.py#L545[John the Ripper].
Although the key derivations are different, Microsoft commonly refers to both types of generated keys as "Cred Keys."